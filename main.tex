\documentclass[12pt,a4paper,oneside]{report} %class

% encode foregin characters
\usepackage[T1]{fontenc}

% hungarian language
\PassOptionsToPackage{defaults=hu-min,classmod=unchanged}{magyar.ldf}
\usepackage{t1enc}
\usepackage[magyar]{babel}
\selectlanguage{magyar}
\usepackage[utf8]{inputenc}

\usepackage[table]{xcolor}

\usepackage{csquotes}

\usepackage{paralist}



% for esoteric file path
\usepackage{grffile}

% load pdf files
\usepackage{pdfpages}

% create neat tables
\usepackage{tikz}
\usetikzlibrary{matrix}
\usepackage{tabularx}
\setlength{\extrarowheight}{2pt}


\newcommand*{\fullref}[1]{\hyperref[{#1}]{\ref*{#1} \nameref*{#1}}} % One single link

% UML
%\usepackage{emp}
\usepackage[school,simplified]{pgf-umlcd}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usepackage{fullpage}

% monospae font

% images 
\usepackage{graphicx}
\graphicspath{ {./images/} }

% set margins
\addtolength{\oddsidemargin}{-1.2cm}
\addtolength{\evensidemargin}{-1.2cm}
\addtolength{\textwidth}{2.4cm}
\addtolength{\topmargin}{-1.5cm}
\addtolength{\textheight}{3cm}

% Figures right after text
\usepackage{float}

% set TOC depth
\setcounter{tocdepth}{4}

% remove red color for hyperref in TOC
\usepackage[unicode]{hyperref}
\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}


% add bibtex
\usepackage[backend=biber]{biblatex}
\BiblatexHungarianWarningOff
\addbibresource{./mainbibliography.bib}

% compare table settings
%\setlength{\arrayrulewidth}{0.1mm}
\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.6}

\newcolumntype{s}{>{\columncolor[HTML]{AAACED}} p{2.5cm}}





%top matter
\title{%
	\includegraphics[scale=0.1]{logo_oe}\\
	ÓBUDAI EGYETEM\\
	Neumann János Informatikai kar\\
	Mérnök informatikus BSc\\
	\vfill
	\large \textbf{Vizuális, interaktív programozás oktató rendszer moduláris megvalósítása\\}
	\large Projektmunka dokumentáció
	\vfill
}
\author{Ráncsik Áron}
\date{\today}

\begin{document}

\includepdf[page={1,2}]{resources/feladatlap}
\pagenumbering{Alph}
\begin{titlepage}
%\maketitle
\thispagestyle{empty}
\end{titlepage}
\pagenumbering{arabic}

%\pagenumbering{Alph}
%\begin{abstract}
%	\thispagestyle{empty}
%	Your abstract goes here...
%	...
%\end{abstract}
\pagenumbering{arabic}

\tableofcontents

% Introductory chapters
\chapter{Bevezetés}
\par 
Az oktatásban manapság elterjedt gyakorlat az oktatott anyag játékos megfogalmazása \cite{riar2020game}, idegen szóval a \textit{gamification} \cite{Deterding2011}. A módszer lényege, hogy a megtanítani kívánt ismeretet  nyers forma helyett, játékos formában tesszük érthetővé a tanulók számára. Dolgozatomban a programozást szeretném a tanulni vágyok elé tárni, olyan formában, hogy az ne okozzon nehézséget, illetve a tanulás emléke inkább egy élmény legyen, egy unalmas óra helyett.
\par Az alábbi célokat tűztem ki. Programozás egyik motivációjának azt szeretném, hogy a felhasználók által készített különböző programkódok, ágensek, egymás ellen tudjanak versenyezni. A programozáshoz ne legyen szükséges konkrét programozási nyelv ismerete. Legyen lehetőség kézvezérléssel végezni a programozást. Az ágensek megmérettetését akár már létező, ismert számítógépes játékokhoz csatlakozva, vagy saját egyedi játékban is lelehessen bonyolítani. További tervezett funkció, hogy az írt kódok összecsapását, kiterjesztett valóságon keresztül is legyen lehetőség követni. 
\par Úgy gondolom, hogy a programozásoktatást egyik legszemléletesebb területe a robotprogramozás, ezért azt célt is kitűztem, hogy az egyetemen elérhető da Vinci robotot is lehessen a rendszer által vezérelni. Magas-szintű program utasítások biztosításának a segítségével könnyen, érthetően lehet szemléltetni a robotika területét is, és a programozáson túl, az orvostudomány robotika iránt is  lehetséges érdeklődést kelteni a fiatalokban.
\par Röviden összefoglalva, a következő irodalomkutatást készítettem a fent megfogalmazott célok ügyében. Első lépésként, a kitűzött célok  megvalósítsa érdekében, a \ref{vizuprogkor} részben a vizuális programozási környezet elkészítésének lehetőségeit részletezem, mely abban segít, hogy egy konkrét programozási nyelv tanulásának kezdeti nehézségein átugorva, vizuális eszközökkel teszi elérhetővé a programozást, akár laikusok számára is. A \nameref{modtan} szekció \ref{davinci} részben azt vizsgálom, milyen lehetőségek vannak a Da Vinci robot egyszerű maga-szintű programozására. A \ref{kitvalo} szekcióban, a napjainkban népszerű, kiterjesztett valóság megvalósításának lehetőségeit részletezem. A \nameref{modtan} utolsó szekciójában \ref{kezvez} a kézvezérlés funkció megvalósításához szükséges ismereteket igyekszem analizálni.

\paragraph{Algoritmus elmélet}
Az algoritmus definiálása nehéz feladat, erre nem vállalkoznék, azt ki merem jelenteni, hogy azokat a feladatokat lehet algoritmizálni, melyek működése Turing-gép segítségével megvalósítható. A fiatalok számára az algoritmikus gondolkozást igyekszem szemléltetni. Az évek során több paradigma kialakult a programozásra, melyek inkább már az absztrakt gondolkozást részesítik előnyben. Úgy gondolom, hogy termesztésen ezeknek is helyük van az oktatásban, de az alapvető algoritmikus gondolkozásmód kialakításához nem szükségesek sőt, véleményem szerint hátráltatóak. A későbbikben részletezett vizuális programozó környezet vizsgálatakor, termesztésen alapvető elvárás volt részemről, hogy az adott megoldás ''Turing-teljes`` legyen. Bár a vizsgált megoldások többsége több, különböző paradigma eszközeit tartalmazza, ezeknek a tulajdonságoknak nem tulajdonítottam különösebb prioritást a vizsgálat során. A későbbiekben választott módszer, a strukturált programozási paradigmát támogatja.

\chapter{Módszertan}
\label{modtan}
A korában megfogalmazott célok elérése érdekében végzett kutatómunkát részletezem, ebben a fejezetben.
Az is célom, hogy az elkészült alkalmazás működése is oktatási célokra bemutatható legyen. Ezért a megvalósítás során, olyan könyvtárakat igyekszem használni,  melyek forráskódja, működése szabadon elérhető. Amennyire lehetséges igyekszem az egyszerűbb megvalósítások irányában hajlani, értem ez alatt azt, hogy inkább olyan megoldások használatát preferálom ami, ''csak`` egy adott feladatra biztosít megoldást, de a használatához nem szükséges egy nagy, bonyolult rendszert használni. Ebből  kifolyólag például mellőzni igyekszem a különböző felhőszolgáltatások és zárt könyvtárak, valamint az ilyen komplett óriási kódbázisok, játékmotorok használatát.
\section{Vizuális programozási környezet}
\subsection{Alternatív megoldások vizuális programozásra}
\label{vizuprogkor}
Mivel a dolgozatban vizuális  programozást  is szeretnék biztosítani, ezért megvizsgálom milyen konkurens megoldások léteznek erre a célra. Az alábbiakban bemutatok és elemzek több kutatást, korábbi kész alkalmazásokat és programkönyvtárakat melyek mindegyike a vizuális blokk alapú programozást biztosítja.
\subsubsection{Scratch} 
\label{scratch}
Nagyon népszerű, oktatásban méltán közkedvelten használt teljes környezet \cite{maloney2010scratch, resnick2009scratch, ScratchUrl2019Jan}, mely vizuális programozást tesz lehetővé. Az alapvető célja olyan média alkalmazások mint pl.: animáció, köszöntések, történet mesélés, zeneklip elkészítésének folyamata közben megtanítani a programozást. Az egyedüli, intuitív tanulás is előnyben részesíti. Főleg kisebb 8-16 éves korosztály számára készült. 
\par Az elkészült program alapértelmezetten egy saját ``{színpad}'' környezetben futtatható. Esemény vezérelt programozást is lehetővé tesz, ebben az esetben az egyszerre fellépő konkurens utasítások között esetleges versenyhelyzetet kezeli, de nem minden esetben úgy ahogy azt elsőre a használó gondolná.  A programból \textit{broadcast} utasításokkal, saját parancsok, szkriptek végrehajtása lehetséges. A \textit{broadcast} utasítássokkal lehetséges a külvilággal történő kommunikáció is, de körülményes. Kiegészítőkkel bővíthető, de így sem lehet az alap működésre kiható szignifikáns módosításokat eszközölni.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Szabadon elérhető, nyílt forráskódú.
	\item Kész megoldásról beszélve, sokkal kevesebb munka segítségével lehet használni.
	\item Egyedi működés \textit{broadcast} utasításokkal lehetséges.
	\item Az alap környezet többnyire magas szintű előre definiált utasításokban gazdag pl.: animációk
	\item Kezdők számára is egyszerűen érthető felület.
	\item Tapasztalatok alapján nagyon ismert az általános iskolások körében.
	\item Érthető, naprakész dokumentáció áll rendelkezésre
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item A \textit{broadcast} utasításon kívül máshogy nem megoldható egyedi utasítás létrehozása.
	\item Az elkészült program csak a saját környezetén belül futtatható, nem lehetséges egyedi környezetben futtatni.
	\item Az elkészült program egyszerűen nem alakítható valódi programkóddá. (Van harmadik féltől származó kész megoldás)
	\item Monolitikus, bővítésre nézve többnyire zárt rendszer.
	\item Ugyan van webes felület, de saját oldalba nem ágyazható.
\end{compactitem}

\subsubsection{Snap} \label{snap}Új, még kevésbé  ismert, teljes megoldás \cite{harvey2013snap}, segítségével vizuálisan van lehetőségünk programozni. A \nameref{scratch}-el szemben több szabadságot biztosít a személyre szabhatóság tekintetében. Sokkal bonyolultabb problémák megoldására is alkalmas, az objektum orientált paradigmát is támogatja. A környezet kevésbé kezdő barát. \textit{Url} utasításokkal webes  csatlakozó felületen keresztül tud fogadó és küldőként is könnyen kommunikálni a külvilággal. A felhő alapú gépi tanulás szolgáltatásokhoz csatlakoztatva akár ``AI'' fejlesztésre is alkalmas \cite{kahn2018ai}. A párhuzamos ciklusokat időosztásos módszerrel futtatja párhuzamosan ``yield'' utasítások segítségével, de erre is igaz. hogy mindezt igyekszik elrejteni a felhasználók elől és nem igényel különösebb beavatkozást az alapvető működéshez hozzá lehet szokni.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Szabadon elérhető, nyílt forráskódú.
	\item Kész megoldásról beszélve, sokkal kevesebb munka segítségével lehet használni.
	\item Egyedi működés \textit{url} utasításokkal lehetséges. Sokkal kényelmesebben mint \nameref{scratch} esetén.
	\item Az alap környezet előre definiált utasításokban gazdag pl.: \textit{sprite}-ok vezérlése.
	\item Bonyolultabb problémák megoldására is alkalmas.
	\item Érthető, naprakész dokumentáció áll rendelkezésre
	\item Van webes felülete, de saját oldalba nem ágyazható.
	\item Egyedi blokkok létrehozását támogatja.
	\item Objektum orientált paradigmát támogatja
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Az elkészült program csak a saját környezetén belül futtatható, nem lehetséges egyedi környezetben futtatni.
	\item Az elkészült program nem alakítható valódi programkóddá.
	\item Nem biztosít felhasználható könyvárat, csak a projekt forrását felhasználva lehet egyedi alkalmazásokban használni.
	\item Jelenleg (\date{\today}) béta állapotban van.
	\item Monolitikus, bővítésre nézve többnyire zárt rendszer.
	\item A objektum orientáltság különböző megkötésekkel érhető el.
\end{compactitem}

\subsubsection{GP} Általános célú blokk alapú \cite{ohshima2015module} \cite{monig2015blocks} programozási nyelv. Egy valódi programozási nyelv mely blokk és kód alapú programozási lehetőséggel is rendelkezik.  Sok alacsony szintű funkciók érhetőek el benne. Sokkal közelebb áll a valóságos programozáshoz a korábban említett lehetőségekhez képest, rendelkezik webes felülettel és a külvilággal internetes \textit{get}, \textit{put} utasítás lehetséges a kommunikáció egyedi rendszerekkel. Támogatja az objektum orientált paradigmát. Tartalmaz bonyolultabb adatszerkezeteket is.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Kész megoldásról beszélve, sokkal kevesebb munka segítségével lehet használni.
	\item Egyedi működés \textit{get, put} utasításokkal lehetséges. \newline Sokkal kényelmesebben mint \nameref{scratch} esetén.
	\item Az alap környezet többnyire alacsony szintű előre definiált utasításokban gazdag pl.: \textit{set pixel} utasítás blokk.
	\item Bonyolultabb problémák megoldására is alkalmas.
	\item Moduláris módon készült.
	\item Érthető, naprakész dokumentáció áll rendelkezésre.
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Az elkészült program csak a saját környezeten belül futtatható, nem lehetséges saját környezetben futtatni.
	\item Az elkészült program nem alakítható valódi programkóddá.
	\item Ugyan van webes felület, de saját oldalba nem ágyazható.
\end{compactitem}

\subsubsection{Alice} Interaktív 3D Animációs környezet \cite{cooper2000alice}. Az idézett kutatás által megfogalmazottan a  célja egy 3D-s környezet interaktív fejlesztése melyben szabadon lehet felfedezni az elkészült alkotást. Főleg szkript alapú prototípus fejlesztő környezet. 
\paragraph{Előnyei} 
\begin{compactitem}
	\item Kész munka elvileg kevesebb munka lehet átalakítani, felhasználni
	\item Adott 3D környezet
	\item Esemény vezérelt programozás tanítására is alkalmas
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Az elkészült program csak a saját környezeten belül futtatható, nem lehetséges saját környezetben futtatni.
	\item Nem vizuális egy sajátos egyedi szkriptnyelvvel rendelkezik.
	\item Az elkészült program nem alakítható valódi programkóddá.
	\item Nincs webes felülete, futtatható állományok telepítését igényli.
	\item Kissé régi, idejét múlt, már kevésbé támogatott.
\end{compactitem}

\subsubsection{Egyéb kész megoldások}
A fenti részben az általam, a dolgozatommal legjobban összehasonlítható szempontok alapján fontosnak tartott kész megoldásokat mutattam be. Természetesen rengeteg egyéb kész alkalmazás létezik mely vizuális programozási lehetőséget biztosít. Felsorolás szintjén itt leírok pár szerintem említésre méltó alkalmazást. 
\begin{compactitem}
	\item Game Maker \cite{jenson2016exploring} 2D játék készítő, vizuális és saját szkriptnyelvvel is rendelkezik. A teljes verzió pénzbe kerül.
	\item Stencyl \cite{liu2014making} 2D Játék készítő alkalmazás melyben vizuálisan lehet programozni.
\end{compactitem}
A továbbiakban kész alkalmazások helyett, vizuális programozásra készült programkönyvtárak bemutatásával fogom folytatni a választható megoldások listáját.  
\subsubsection{Blockly}
\label{blocly}
Google által fejlesztett, vizuális programozást támogató programkönyvtár \cite{BlocklyUrl2020Feb} \cite{pasternak2017tips}. A vizuális megjelenésért felelős, nem egy programozási nyelv, csak egy vizuális leíró nyelv, mely könnyedén exportálható vallós programozási kóddá. Több létező programnyelv kódot lehet a vizuális környezetből generálni, többek között: JavaScript, Python, Lua, Dart nyelvű kódokat is. A Blockly könyvtárat sok kész alkalmazás használja a saját egyedi vizuális környezetének megvalósítására.
Például a korábban említett \nameref{scratch}, \nameref{snap} is használja vizuális könyvtárként, de az ezután részletezett \nameref{pxt} környezet is Blockly-t használ a vizuális megjelenítésre.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Szabadon elérhető, nyílt forráskódú.
	\item Kezdők számára is egyszerűen érthető felület.
	\item Érthető, naprakész dokumentáció áll rendelkezésre.
	\item Program könyvtár, könnyen bővíthető egyedi utasításokkal
	\item A program futtatási környezetére nincs megkötés.
	\item Nemzetközi. Több mint 40 (köztük magyar) nyelven elérhető.
	\item Bármilyen futtatási környezetbe könnyen integrálható.
	\item Rengeteg programkód generálható.
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Csak egy vizuális programozást támogató  ``drag \& dropp'' programkönyvtár.
	\item Viszonylag régi technológiákkal készült, nehézkes modern környezetben használni.
\end{compactitem}

\subsubsection{MakeCode (PXT)}
\label{pxt}
Microsoft által fejlesztett, összetett, vizuális programozói környezetet biztosító, nyílt forráskódú programkönyvtár \cite{seneviratne2019makecode}. A \nameref{blocly} könyvtárat felhasználja a blokk alapú vizuális programozás biztosítására. A blokk alapú programozáson túl biztosít lehetőséget a szöveges programozásra is, egy beépített weboldalon futamítható fejlesztő környezetben. Abban különbözik a korábbi alternatív lehetőségektől, hogy egyben nyújt egy teljes fejlesztő környezetet, amihez könnyen hozzá lehet csatolni egy saját \textit{target} modult egyedi utasításokkal. A \cite{devine2018makecode} kutatás részletesen bemutatja, hogyan lehet használni beágyazott rendszerekhez. A fejlesztő környezethez alacsony szintű mikrokontrollerhez való fordítót csatlakoztatva.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Szabadon elérhető, nyílt forráskódú.
	\item Kezdők számára is egyszerűen érthető felület.
	\item Érthető, naprakész dokumentáció áll rendelkezésre.
	\item Program könyvtár, könnyen bővíthető egyedi utasításokkal
	\item A program futtatási környezetére nincs erős megkötés.
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Integrálása korlátozott, alkalmazkodni kell a felépítéséhez, ettől eltérni nem lehetséges könnyen.
	\item Béta verzióban van a fejlesztés.
\end{compactitem}

\subsection{Választott vizuális programozási környezet}
Kipróbáltam, teszteltem a legtöbb felsorolt megoldást, továbbá a korábbi elemzés összevetése  után a Blockly környezet használata mellet döntöttem.
A dolgozat igényeit nem lehet kész megoldásokkal pl. \nameref{scratch}, \nameref{snap} stb. kielégíteni, mert túlságosan zárt működésük nem teszik lehetővé, hogy egyedi környezethez lehessen programozni ezekben az alkalmazásokban.
A Blockly kellőképpen módosítható és könnyen egyedi környezetbe illeszthető, vizuális programozást biztosító programkönyvtár, mely megfelel a feladat részéről támasztott elvárásoknak, továbbá kellőképpen egyszerűen használható.


\section{Da Vinci}
A célok között szerepelt a da Vinci robot egyszerű vezérlése. 
Az elkövetkező részben, igyekszem körbejárni a lehetőségeket és elemezni előnyeit hátrányait, melyek segítségével lehet kapcsolódni a da Vinci rendszerhez. Az egyetemen egy 2010-ben bemutatott első generációs da Vinci classic rendszerhez van lehetőség hozzáférni, ezért ehhez készül az alkalmazás. A továbbiakban mindig erről a modellről lesz szó.
\subsection{Robot Operating System}
Annak érdekében, hogy a fejlesztés során, ne kelljen folyamatosan egy fizikai da Vinci rendszerrel dolgozni, egy olyan környezetre van szükség ami képes biztosítani da Vinci robotot virtuálisan. Több rendszer elérhető mely robot programozás vezérlő környezetet biztosít, csak felsorolás szintjén néhány \cite{BibEntry2020May, montemerlo2003perspectives}, azonban az egyik legkorábbi és legnépszerűbb lehetőség a Robot Operating System \cite{quigley2009ros} továbbiakban ROS. A ROS órási és növekvő közösséggel rendelkezik, \textit{de facto} standard az iparban és kutatásban. Dolgozatomban több szempont miatt is a legjobb választásnak a ROS rendszer bizonyult. Attól a hátrányától eltekintve, hogy nem multiplatform azaz csak Ubuntu GNU/Linux és annak is csak bizonyos verzióihoz támogatott hivatalosan, rengeteg előnnyel rendelkezik. Sok robotvezérléssel kapcsolatos alapfunkciót tartalmaz, amit így nem kell újból megírni, biztosít egy jól elszeparált keretet külön a kommunikációra és az üzleti logikára.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Szabadon elérhető, nyílt forráskódú
	\item Kiforrót
	\item Népszerű
	\item Moduláris
	\item Kutatási célokhoz megfelelő
	\item Érthető, naprakész, jó dokumentáció áll rendelkezésre
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Nem multiplatform, csak Ubuntu GNU/Linux és annak is csak bizonyos verzióihoz elérhető
\end{compactitem}

\subsection{Da Vinci Research Kit}
\label{davinci}
A da Vinci Research Kit továbbiakban dVRK egy nyílt forráskódú rendszer, ami lehetővé teszi a Da Vinci robot karok programozását \cite{kazanzides2014open}. Gyakorlatilag ''firmware``-ként lehet rá tekinteni, ami képes meghajtani a robotkarokat.  A ROS rendszerhez kapcsolódik, könnyen lehetséges az utasításait használni egy ROS  modult biztosít használatra.  A célkitűzéseimhez képest viszonylag alacsony-szintű da Vinci robotkarvezérlő utasítások kiadására alkalmas.
Ennek a modulnak a segítségivel lehetséges a ROS rendszerrel da Vinci robotot vezérelni, továbbá virtuálisan szimulált robotkar létrehozása is lehetséges. Erre keretrendszerre mindenképp szükség van amennyiben ROS rendszerhez szeretnénk kapcsolni a da Vinci robotot. 
\subsection{iRob Surgical Subtask Automation Framework}
\label{irob}
Nagy D. Tamás és Haidegger Tamás által fejlesztett keretrendszer továbbiakban SAF \cite{irobsaf2019}.
Alapvetően arra a célra készült, hogy részleges automatizáció segítségével levegye a sebészekről a kognitív terhelést. Részfolyamatok automatizálását teszi lehetővé a keretrendszer. A ROS rendszerben elérhető modulokat biztosít, a dVRK rendszerre épül. Használata során felépít egy hierarchikus modul rendszert, melynek a legmagasabb szintjén magas-szintű utasítások kiadása lehetséges. Számomra a céloknak tökéletesen megfelelő.
\paragraph{Előnyei} 
\begin{compactitem}
	\item Szabadon elérhető, nyílt forráskódú
	\item Moduláris
	\item Alkalmas Kutatási célokhoz
	\item Érthető, naprakész, jó dokumentáció áll rendelkezésre
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Jelenleg fejlesztés alatt áll.
\end{compactitem}


\section{Kiterjesztett valóság}
\label{kitvalo}
A célok között szerepelt egy olyan funkció, melynek a segítségével lehetséges kiterjesztett valóság segítésével követni a játékmenetet. Itt szeretném részletezni a hasonló megoldásokat, azokból levont következtetéseket.
A \cite{azuma2001recent} kutatásból idézve  kiterjesztett valóságot a következő módon definiálhatjuk. Az a rendszer, ami a következőket teljesíti:
\begin{compactitem}
	\item Kombinálja a valós és virtuális objektumokat a valós környezetben.
	\item Azonnal fut, és valós időben.
	\item Egymáshoz rögzíti (igazítja) a valós és virtuális objektumokat.
\end{compactitem}
Továbbikban az AR rövidítést fogom használni. 
Virtuális objektumokat szeretnénk elhelyezni a kamera képen úgy, hogy azok mozgása a kamera 3D mozgásához igazodjon. 
\par Több létező megoldás van AR elkészítéséhez, ezen megoldások összehasonlításáról lesz itt szó.
A legtöbb esetben nagyobb gyártók szolgáltatásaként lehetséges használni.
\subsection{Alternatív kiterjesztett valóság megoldások}
\subsubsection{Unity}
Unity Technologies által fejlesztet játékmotor. 2D és 3D számítógépes játékok elkészítésre alkalmas. Napjaink egyik, ha nem a legnépszerűbb játék fejlesztő motorja \cite{haas2014history}.
Rengeteg játékkészítéssel kapcsolatos funkciót biztosít. AR megvalósításához rendelkezik saját megoldással. Itt \cite{kim2014using} egy példa látható arra, hogyan lehetséges a Unity beépített AR megoldását használni és milyen előnyök származnak ebből, illetve a Unity használatából. Az előbbi hivatkozott példában láthatjuk, hogy rengeteg kényelmi funkcióval rendelkezik, melyek használata, csupán kiterjesztett valóság rendszerekben, játékmotor nélkül, sokkal körülményesebb.  További előnye, hogy a Unity rendszerrel készült alkalmazások az összes ma használatos platformra fordíthatóak. 
\paragraph{Előnyei} 
\begin{compactitem}
	\item Ingyenesen használható
	\item Érthető, naprakész, jó dokumentáció áll rendelkezésre
	\item Használata könnyű
\end{compactitem}
\paragraph{Hátrányai} 
\begin{compactitem}
	\item Nagyon nagy függőség
	\item Kifejezetten játék fejlesztésre van, rengeteg extra funkcióval rendelkezik
	\item Nem lehetséges csak modulként használni
	\item Feltétlen alkalmazkodni kell a használatához
	\item Nem nyílt a forráskódja
\end{compactitem}
\paragraph{Konklúzió}
Úgy gondolom, hogy túlságosan nagy erőforrás és munka pazarlás lenne Unity-t csak kiterjesztett valóság elkészítésére használni. Egyáltalán nem vagy csak nagyon sok plusz munka árán lehetne alkalmazásba integrálni, inkább az alkalmazást kellene a Unity-be integrálni használata esetén.

\subsubsection{Unreal Engine}
Egy szoftver amely valósidejű 3D grafika készítésére készítettek \cite{unrealengine}. Szűkebb értelemben játékmotornak is lehet  nevezni. Szintén rendelkezik saját megoldással Virtuális valóság (VR), AR és kevert valóság (MR) számára is.
\paragraph{Konklúzió} Többnyire ugyanazok igazak rá mint a Unity-re ezért külön nem tárgyalom. A fejlesztést marginálisan meghatározná, a motor használatához kellene alkalmazkodni.
\subsubsection{Mobil megoldások}
\paragraph{iOS ARKit}
Az ARKit segítségével, Apple iOS platformra lehetséges AR alkalmazást készíteni \cite{arkit}. A korábban említett különböző maga-szintű megoldások pl. Unity ezt a rendszert is használja, ha iOS platformra készítünk projektet. Egy AR alkalmazás számára szükséges összes funkciót megvalósítja, pl. a telefon kamera pozíció becslését, virtuális objektumok elhelyezését. Természetesen mint mobil megoldás, a telefon kameráját illetve szenzorrendrendszerét használja a működéshez.
\paragraph{ARCore}
Hasonlóan az ARKite-hez, az ARCore a modern Android operációs rendszerrel rendelkező telefonokon elérhető kiterjesztett valóságot biztosító API \cite{arcore}.
\paragraph{Konklúzió}
Az előbb említett megoldások használatához Andoid vagy iOS alkalmazás készítése szükséges. A legtöbb játékmotor is ezeket a megoldásokat használja mobil platformokon. Ezeknek a rendszereknek a teljes műkése rejtett, egy API-t biztosítanak melyen keresztül lehetséges használni, ugyan az API-n keresztül minden kínált funkció elérhető ,a működéshez ezen túl nem lehet hozzáférni. Ezek a megoldások jól működnek, de egyedi igényeket nem lehetséges velük kiszolgálni. A működésüket nem lehet megismerni, továbbá zárt forráskódú rendszerek. Ezeket figyelembe véve, számomra nem megfelelőek.
\subsubsection{Egyéb kész megoldások}
Itt olyan megoldásokat említek, melyeket kész alkalmazásként vagy könyvtárként lehetséges használni. Felsorolás szintjén a Vuforia \cite{vuforia}, Wikitude \cite{wikitude}.
Ezekről általánosan elmondható, hogy használatuk részben vagy teljesen nem ingyenes. Igyekeznek saját komplett felhőszolgáltatást kényszeríteni a használathoz. Forráskódjuk ezeknek is zárt. Használatukhoz a biztosított API-t kell használni egyedi megoldások megvalósítása ezekkel is körülményes.  A felsorolt hátrányok miatt számomra alapvetően nem alkalmasak használatra.
Az EasyAR \cite{ezar} és Kudan \cite{kudan} rendszerek használata bizonyos feltételek mellet ingyenes, de forrásuk továbbra is zárt. Többnyire ezekre is igazak a  fizetősekre felsorolt hátrányok.

\subsubsection{Egyedi megoldás}
Egy jó lehetőség lehet, saját kiterjesztett valóság megvalósítása, ingyenes program könyvtárak segítségével.
Azt értem az ilyen megoldás alatt, hogy a készítés során alacsonyabb-szintű gépi látás könyvtár segítségével egy saját kiterjesztett valóság szolgáltatást építünk. Egy ilyen megoldásnak több nehezebb feladatot kell tudni megoldania. A kiterjesztett valóság elkészítse a feladat és nem pedig mint AR szolgáltatás használata. Elkészítése a korábbiaknál nagyobb kihívást jelent. Az elérhető ''kész`` alkalmazások, könyvtárak komplett fejlesztő csapatok által, több év óta folyamatosan fejlesztés alatt vannak. Így teljesítmény szempontjából ezekkel szemben felvenni a versenyt szerintem lehetetlen, viszont modularitás és megérthetőség szempontjából úgy gondolom, hogy van értelme megpróbálni. A különböző megvalósítási lehetőségek megértése és adott feladathoz történő választása továbbra is egy előny, mert nem feltétlen kell általános megoldást készíteni.

\par Az egyik legnépszerűbb és  legjobban elterjedt gépi látással kapcsolatos programkönyvtár az eredetileg Intel által fejlesztett,  majd később nyílt forráskódú közösség által, a mai napig is folytatott OpenCV \cite{opencv_library}. Az OpenCV \cite{pulli2012real} \cite{opencv}
\subsection{Választott módszer}
Számomra fontos volt, hogy az AR rendszer átlátható kegyen, nem csak egy használható, de a működését megismerhető rendszert szeretnék használni. Korábban már többször említettem, hogy különböző játékmotorok használatát elvetettem, mert túlságosan alkalmazkodni kellene hozzá. 
\par A felsorolt (többnyire) zárt könyvtárak, használata sem biztosítja a megfelelő szabadságot, továbbá előnytelennek találtam azt, hogy forrásuk zárt.


\begin{figure}[H]
	\centering
	\begin{tabular}{s|p{3.5cm}|p{3.5cm}|p{3.5cm} }
	%\hline
	%\rowcolor{lightgray} \multicolumn{3}{|c|}{Country List} \\
	%\hline
	& Játékmotorok &(Részben) fizetős könyvtárak &  Egyedi megoldás \\
	\hline
	Forráskód & Zárt & Zárt & Nyílt \\
	%\rowcolor{gray}
	AR Sebesség & Jól optimalizált & Jól optimalizált & A fejlesztő feladata az optimalizáció \\
	Egyedi igények   & A maga játékmotor kínál rengeteg lehetőséget, hozzáköt a motorhoz & Saját ökoszisztémát nyújt, vagy korlátozottak a lehetőségek   & Teljes mértékben lehetőségünk van egyedi igények megvalósításra  \\
	Ár & Bizonyos feltételek mellet ingyenes & Bizonyos feltételek mellet ingyenes & Ingyenes\\% \cellcolor[HTML]{AA0044}

	%\hline
	\end{tabular}
	\caption{Főbb AR lehetőségek összehasonlítása}
\end{figure}

A különböző megoldásokat összehasonlítva, a saját AR megoldás megvalósítása mellet döntöttem. Fő indokom, egy olyan rendszer készítése, melynek a működése megérthető ennélfogva, amennyire lehetséges nem támaszkodik fekete-dobozokra.
\section{Hasonló megoldások}

Gyakorlati \cite{prochazka2011augmented} összefoglalót láthatunk  arról, hogy különböző alkalmazások segítségével milyen kihívásokkal kell szembenézni AR megvalósítása során. 
todo
\section{Saját AR készítéshez szükséges irodalomkutatás}
Annak érdekében, hogy saját AR rendszert készítsek, igyekeztem utána járni a lehetséges módszereknek, és azok alapfogalmainak.
Alapvetően abból indultam ki, hogy egy átlagos telefon kameraképeivel működjön a rendszer, így reális minőségű képekkel tudok dolgozni.
\subsection{Kamera kalibráció}
Kalibrált képen a valóságban egyenes szakaszok a képeken is így fognak megjelenni. Egy kamera rendelkezik külső és belső tulajdonságokkal. 
\paragraph{Külső tulajdonság} Így nevezzük, a 3D pozíció és  orientáció együttesét. Az előbb említett összetett  tulajdonság különösebb bizonyítás nélkül belátható, hogy egy transzformációs mátrix segítségével leírható.
\paragraph{Belső tulajdonság} 
Összetett tulajdonság mátrixban tárolva. A kamera középpontjának koordinátáit, a pixelek méreteit tartalmazza.  A kamerák képei nem tökéletesek. Tangenciális torzulás lehetséges az objektív miatt, ezt hívják halszem hatásnak is, ennek a korrigálását teszi lehetővé ezen tulajdonságok pontos meghatározása. 
\par  A kamera külső és belső paramétereinek megismerése érdekében a kamerakalibráció egy szükséges lépés a 3D gépi látáshoz. Itt \cite{zhang1999flexible} láthatunk, egy  napjainkban is elterjedt módszer működését.
\paragraph{A bemutatott kalibráció előnyei} 
\begin{compactitem}
	\item Nem igényel különösebben drága felszelést. 
	\item A folyamat könnyen kivitelezhető a kamera, mintázat szabad kézzel tartható 
	\item Pontosabb mint, az automatikus kalibrációs módszerek.
\end{compactitem}

\subsection{Képpontok egymásnak megfeleltetése}
Egy digitális képen alapvetően színek, fényességértékek sokaságaként tárolunk, ebből szeretnénk egy adott pontot megnevezni. A következő megközelítéseket vizsgáltam meg. Egy egyszerűbb megközelítés, a klasszikusnak számító Multiple View Geometry című könyvben is találunk \cite[ó.~140]{hartley2003multiple}, melyben példaképp RANSAC \cite{derpanis2010overview} algoritmus segítségével, közelít optimális képpont megfeleltetést. Legegyszerűbben szerintem ezen a példán érthető meg.

\paragraph{Jellemző pontok keresése}
Az úgy nevezett, \textit{wide baseline stereo} megközelítésbe tartozik eza fajta megközelítés.
Bizonyos jellemzők \textit{feature} alapján lehetséges jellemezni képen egy pontot. Az a cél, hogy az adott karakterisztika, tulajdonság amivel jellemeztünk egy pontot, folyamatosan minél tovább, megmaradjon az egymás utáni képeken. Így az adott ''egyedi`` pont, több képen is beazonosítható. A jellemzőt előállító algoritmust \textins{feature descriptor}-nak hívja szakirodalom. Később fogok  ezzel részletesebben foglalkozni.

\paragraph{Jellemző leírók}
Egy képből jellegzetes, többnyire nagy lokális kontrasztú pontokat jelölünk el. Ezeket a pontokat fényviszony változása mellet, illetve átméretezett és átforgatott képen is szeretnénk megtalálni, ezt utóbbit hívják méretezés és forgatás invarianciának.
\begin{figure}[H]
	\centering
	\begin{tabular}{s|p{3.5cm}|p{3.5cm}|p{3.5cm} }
		%\hline
		%\rowcolor{lightgray} \multicolumn{3}{|c|}{Country List} \\
		%\hline
		& SIFT \cite{lowe2004distinctive} & SURF \cite{bay2006surf} &  ORB \cite{rublee2011orb} \\
		\hline
		Ingyenes? & Nem & Nem & Igen \\
		Méret invarián? & Igen & Igen & Igen \\
		Forgatás invariáns? & Igen & Igen & Nem \\
		Elterjedtség & Mára kevésbé népszerű & Népszerű & Népszerű \\
		Egyéb tulajdonság 
		& Képes a pontról 8 irányban gradiens jellemzők alapján beazonosítást végezni.
		Minden talált ponthoz egy orientációt is meghatároz. 
		& A SIFT gyorsított változat., Kicsit pontatlanabb, de sokkal gyorsabb. Jól párhuzamosítható algoritmus. Közelítő módszerekkel számol, a gyorsaság édenkében 
		& Ingyenes alternatíva a SIFT és SURF algoritmusokra. Több módszer kombinációjaként született meg.\\
	
		%\hline
	\end{tabular}
	\caption{Jellemző leírók összehasonlítása}
\end{figure}


\paragraph{Optikai-folyam}
\textit{Optical Flow} (OF), \textit{Small deformation} kategóriába lehet sorolni, mely alap feltételezésében eltér a korábban említett \textit{wide baseline stereo} megközelítéstől. Az alap feltételezés, hogy nagyon kicsi két képkocka között a különbség, továbbá egy adott és pixel környezet, nem feltétlen ugyanolyan, de hasonló  mozgást végez. A teljes mozgás \textit{smooth}, sima, nincsenek olyan pixelek amik külön utat járnak.  A modell \textit{dense} sűrű ábrázolására alkalmasak, ellentétben a jellemzőpont keresésessel.Kötelező megemlítenem a Lucas-Kanade \cite{lucas1981iterative} és Horn-Schunck \cite{horn1981determining} egyszerre, igen korán 1981-ben bemutatott kutatását. Horn a az összes pixelhez  mozgás vektort rendel, ezért a korai időszakban nem volt valósidejű, de mára már annak lehet tekinteni. Kanade megoldása viszont, könnyebben megérthető. Ma már alap algoritmusnak annyira közkedvelt és alapvető algoritmusnak számítanak, hogy videokártyák minta kódja között is lehet találkozni ezekkel.
 

\subsection{Kamera mozgásának rekonstrukciója}
Miután ismerjük a kamera tulajdonságait a képekkel torzítás mentesen tudunk a továbbiakban dolgozni.
A kamera mozgásának meghatározása a kamerával készült képekből. A videó feldolgozása során, szeretnénk minden képhez egy merev-test mozgást meghatározni, melyre igaz, hogy a virtuális objektumra történő alkalmazás esetén a tanformáció után az objektum a kamera képen, megfelelő szögbe és pozícióba kerül az objektum. (Az első kép esetén természetesen külön kell dönteni a virtuális objektum elhelyezkedéséről.)

\subsubsection{Simultaneous Localisation and Mapping}
Meg kell különböztetni az ismert és ismeretlen \textit{scene} ''jelenet``-ben történő kamera \textit{tracking} ''követés``-t. Ismeretlen jelenet esetén, egy lehetséges kidolgozott megközelítés a ''Simultaneous Localisation and Mapping`` (SLAM). Egy módszer arra, hogy a kialakított modell, \textit{structure} és kapott kép információk alapján lehetőleg minél pontosabban szeretnénk a kamera merev-test mozgását meghatározni.
Az egyik nagy előrehaladás a 2003-ban bemutatott sokat hivatkozott valósidejű megvalósítás \cite{davison2003real}. A megoldás egy kamerát használt, \textit{monocular} SLAM-nek szokás nevezni. 
Az ötlet a Kálmán szűrőn alapszik \cite{welch1995introduction}, mely a egy optimális becslő algoritmus. Egy modell állapotából és tapasztalat által szerzett zajos állapotból igyekszik optimális állapotot meghatározni. Ennek egy továbbfejlesztett megoldására latunk példát itt \cite{klein2008improving} mely a modellt magasabb szintű részekkel bővítette ki. A SLAM módszerekről elmondható, hogy legtöbb esetben a jellemző képpontok keresését és azok egymásnak való megfeleltetésének módszereket használnak, de optikai-folyam módszer alapján is működhetnek. 
Robotika területén, gyakran alkalmazzák, legtöbb specifikus programkönyvtár több variánsát támogatja.

\subsection{Saját AR, jelölő keresésén alapuló módszerrel}
Az eddigiektől egészen eltérően megközelítés. A kamera mozgásának meghatározása helyett, egy előre ismert \textit{marker}, ''jelölő``  keresése a cél. 

Egy előre kiszámolt hasítótáblázatból keres jelölőket a képeken. Fontos, hogy a jelölők konkrét fizikai méretének az ismeret is szükséges. Bináris négyzet alakú jelölőket keres. 
A \cite{garrido2014automatic} munkában részletesen leírják a jelölők detektálásának működését. Nagy vonalakban a következőképpen működik. 
\begin{enumerate}
	\item Szűrést véges négyzetnek tűnő alakzatokra, ezeket a jelölteknek hívjuk. Itt érdemes megemlíteni, hogy a keresett négyzetek tetszőlegesen elforgatva lehetnek a képeken.
	\item  Miután a jelöltek megvannak a tartalmukat bizonyos szabályossági tesztnek, idegenszóval a kijelölt négyzet belső tartalom kodifikációját kell ellenőrizni. Magyarán ellenőrizzük, hogy megfelel-e bizonyos szabályoknak, pl. mivel a jelölők mind fekete sávval vannak körbe véve, ezért lehet vizsgálni hogy a konkáv tulajdonságnak megfelelnek-e fekete sávok, vagy egyéb komplexebb tulajdonságot.
	\item Az elkészült modul, élő kamera folyamon próbál keresni egy előre megadott jelölő listákból minél többet, majd megjeleníti a 3D-s elhelyezkedését a talált jelölőknek.
\end{enumerate}
egy    Jelző beazonosításhoz szükség van kalibrált kamerára, magyarán ismerni kell a kamera és objektív torzulás mátrixokra, mert a torzítást ki kell korrigálni a keresés elött. Ezt a feladatot a OpenCV Aruco könyvtár segítségével oldottam meg.  A jelölő detektálást a könyvtár végzi. Az eredmény 6 jelölő alapú póz meghatározás ábrán is látható, a módszer valós idejű gyors, 

\paragraph{Összehasonlítás a korábbi ötlettel}
 Ennek a feladatnak a megvalósítása sokkal kisebb számítás igénnyel rendelkezik.

\begin{figure}[H]
	\centering
	\begin{tabular}{s|p{5.5cm}|p{5.5cm} }
		%\hline
		%\rowcolor{lightgray} \multicolumn{3}{|c|}{Country List} \\
		%\hline
		& AR kamera pozíció rekonstrukcióval &  AR jelölő kereséssel \\
		\hline
		Kamera kalibráció & Szükséges & Szükséges \\
		Erőforrásigény & Magas & Közepes \\
		Használatához szükséges eszközök & Kamera & Kamera, jelölő \\
		Megvalósítás & Bonyolult & Kevésbé bonyolult \\
		Előnyök, hátrányok 
		& Jól tűri a hibákat, viszont jelölő nélkül nem használható. 
		& Robusztusabb rendszer, elfordulhat drift jelenség.
		
		%\hline
	\end{tabular}
	\caption{Saját AR alapvető ötleteinek összehasonlítása}
\end{figure}


\subsection{Saját AR Konklúzió}
Az előbb tárgyalt módszerek, legtöbbjének legalább alapvető ismeretére, de adott esetben a teljes  működésével tisztában kell lenni, saját AR készítése során. Előreláthatólag nem lesz könnyű feladat megvalósítani. Főleg a futásidőre történő optimalizáció szempontjából sokkal rosszabb helyzetben van, mint nagy gyártók által elkészült alternatívák. Mérlegelve a feladat nagyságát és értelmét, arra döntésre jutottam, hogy saját AR rendszer elkészítésébe kezdek. Úgy gondolom, hogy megéri ezen a területen kutatni, és egy egyszerűbb, de teljesen igényeknek megfelelő AR alkalmazást készíteni, ha más nem a elkészítés során szerzett új ismeretek miatt is.

\chapter{Részletes munkaterv}
asdasd
\begin{figure}[H]
\end{figure}
\chapter{Megvalósítás}
\section{Kézvezérlés}
\label{kezvez}
\section{Kamera mozgás becslés}
\subsection{Markerek keresése}

\section{Da Vinci vizuális programozási környezete}
A korábbi irodalomkatatusban arra a következtetésre jutottam hogy a Blockly rendszert fogom használni a  grafikus programozás megvalósítására.
A da Vinci kar programozásának a példáján keresztül fogom bemutatni a létrehozott vizuális programozási környezetet.
A Blockly egy JavaScript könyvtár melyet böngészőből lehetséges használni. Az Blocly használatával készült weboldal kiszolgálásához NodeJS szervert választottam. Úgy gondolom, hogy NodeJS segítségével kellőképpen egyszerűen lehetséges a weboldal kiszolgálása és WebSocket szervert készítése is könnyen megvalósítható. A NodeJS szerver segítségével három fontosabb modult létrehoztam. A vizuális programozást biztosító továbbiakban ''editor`` modul, a felhasználó által létrehozott ágens futtatására alkalmas ''view`` modul és a különböző felhasználók adminisztratív kezelésére szolgáló ''control`` modul.
\subsection{Control}
Ennek a modulnak a segítségével ki tudjuk listázni az alkalmazáshoz csatlakozott felhasználókat. A csatlakozott felhasználók által létrehozott Blockly utasítás struktúrák minden módodaíráskor automatikusan mentésre kerülnek. A ''control`` modul segítségével lehetséges egy felhasználó egy mentett struktúrájának a betöltése a  ''view`` modulba. Az teljes alkalmazásnak van olyan funkciója melynek segítségével a felhasználók által létrehozott ágensek küzdhetnek egymással, ennek a kezelése is ebből a modulból érhető el ez keserűbb részletezem. Jelen példában maradunk a da Vinci programozásánál. A da Vinci számára létrehozott algoritmust miután betöltjük a ''view`` modulba akkor ''control`` modulnak van lehetősége azt elindítani a da Vinci rendszeren. 
\subsection{Editor}
Ez a módul ténylegesen használja a Blockly könyvtárat. Böngészőből a felhasználóknak van lehetősége ezt a modult használni. Ennek a segítségével vizuálisan lehetséges algoritmusokat létrehozni. A da Vinci rendszert programozásához szükséges volt egyedi utasítások létrehozása, hogy a da Vinci rendszer számára tudjunk magas-szintű utasításokat létrehozni. Jelen esetben még csak tárgyak megfogásának utasítását lehetséges használni.
\begin{figure}[H]
	\centering
	\label{fig:myblockly}
	\includegraphics[width=10cm]{myblockly}
	\caption{A felhasználó által használható editor felület. }
\end{figure}

\subsection{View}
Ebbe a modulba töltjük  a felhasználók által létrehozott algoritmust, illetve itt van lehetőség annak futtatására. A ''control`` modul tölti be a kiválasztott felhasználó Blockly utasításait, a Blockly utasítások JavaScript nyelvi utasításokra fordulnak ebben a modulban. A különböző Blockly utasítások számára itt lehetséges egyedi JavaScript utasításokat definiálni. A JavaScript-re fordított ágens kódját ''JS-Interpreter`` segítségével futtatom \cite{BibEntry2020Feb}. A ''JS-Interpreter`` egy JavaScriptben írt JavaScript értelmező ''sandbox`` környezet, melyben biztonságosan van lehetőségem elválasztani az ágensek kódjait a böngésző valós JavaScript motorjától. Az ágensek kódja csak és kizárólag egyedileg definiált függvények segítségével tudnak kommunikálni a valós környezettel ezt a dokumentáció ''API hívásnak`` nevezi, jelen esetben a ''JS-Interpreter``-t könyvtárat használó fejlesztő feladata a hivatkozott ''API`` elkészítése. Az utasítások végrehajtása nem valós-időben történik, folyamatosan megvárja a utasítás végrehajtásának sikerességét. 

\begin{figure}[H]
\centering
\label{fig:davinciblock}
\includegraphics[width=10cm]{davinciblock}
\caption{A da Vinci számára történő utasítás kiadására alkalmas Blockly vezérlési szerkezet }
\end{figure}

\section{Da Vinci webes elérhetősége}
Először meg kellet ismerkednem a ROS architektúra és a korábban részletezett \ref{irob} SAF keretrendszer használatával.
A SAF felépítését a \ref{fig:irob} ábra szemlélteti. A SAF ''subtask`` nevű legfelső moduljában található ''megfogás`` művelet külső meghívásának megvalósítását készítettem el. A meglévő SAF kódból leágazva Létrehoztam egy  ROS web modult, amely ROS action kezelésére alkalmas. Az új modul a ''web`` témakörre van feliratkozva, innen vár goal definíciókat, amiket kiszolgálhat. Jelenleg csak a megfogás művelet van implementálva, de később kibővíthető a további műveletek elvégzésére is. ROS szolgáltatásként lehetséges elindítani a webes modult. Összefoglalva a következőképpen működik: a ROS web modul a következő részben ismertetett \nameref{roslibjs} segítségével lehetséges megszólítani. A webes kérés ROS action formában érkezik. Amennyiben kérés érkezett a SAF \nameref{irob} modult hívja a kérésnek megfelelő utasítással. A mennyiben a kiadott utasítás sikeresen befejeződött ezt egy action alapértelmezett műjkédésének megfelelően egy sikeres callback függvény segítségével visszajelzi a kérést kiadó böngészőnek. A böngésző és a  ROS közötti kommunikáció a \nameref{roslibjs} működéséből következően WebShocket protokollon keresztül történik. A WebShocket protokol előnye a http-vel szemben, hogy kétirányú kapcsolat könnyű kialakítására alkalmas.

\begin{figure}[H]
	\label{fig:irob}
\begin{center}
	\includegraphics[width=14cm]{irobArch}
	\caption{A SAF sematikus működése, felépítése \cite{Abc-irobotics2020May} }
\end{center}
\end{figure}
\begin{figure}[H]
	\centering
	\label{fig:irob_web}
	\includegraphics[width=14cm]{irob_web}
	\caption{ROS web node ki/be meneteli csatlakozásai}
\end{figure}
\newpage
\subsection{Standard ROS JavaScript könyvtár}
\label{roslibjs}
A Standard ROS JavaScript könyvtár továbbiakban roslibjs a Robot Web Tools része \cite{toris2015robot}.  Alap JavaScript könyvtár, ami a ROS környezettel való böngészőből történő interakció kialakítására készítettek. A Robot Web Tools olyan eszközök fejlesztésének gyűjteménye melyek célkitűzése a ROS rendszer böngészőből történő használatához készítenek, napjainkban is folyamatosan egyre több funkciót lehetséges elérni benne. A könyvtár két részből áll. Biztosít egy JavaScript könyvtárat melyen keresztül kéréseket tudunk megfogalmazni a ROS szerver számára nevezzük ezt most JavaScript könyvtárnak. A Robot Web Tools legfontosabb része a \textit{rosbridge} protokoll ami a kiadott kérések fogadására van. A \textit{rosbridge\_server} egy ROS szolgáltatás amit el kell indítani, hogy továbbítsa a kéréseinket megfelelő modulok számára.
\subsubsection{JavaScript könyvtár}  A segítségével ROS alapértelmezett kommunikációs rendszeréhez lehet kéréseket küldeni, üzenet küldések, szervizhívások, és akcióhívások segítségével. A hívás válaszakor egy eseménykezelő \textit{callback} függvény meghívódik (WebShocket-es esemény hatására), amiben le tudjuk kezelni, hogy mi történjen a kiadott utasítás után. Mint korábban már említettem a hálózati kommunikáció a WebShcoket protokoll \cite{fette2011websocket} használatával történik, ennek a segítségével hálózaton keresztül egyszerű esemény alapú programozást lehet megvalósítani, a JavaScript az ilyen típusú programozás közkedvelt nyelve.
\section{Da Vinci vizuális programozás összefoglaló}
A ROS modulok használata jelenleg Ubuntu 16.04-es verzióval van tesztelve. A Web modulokat én a mindenkori legfrissebb Manjaro Linux alól tesztelem, de elvi szinten bármilyen disztribúció alkalmas ezek használatra, a megfelelő függőségek feltelítése után. Az Ubuntu 16.04-et javaslom virtualizált környezetben futtatni.
Az alkalmazás szimulációval történő  da Vinci programozás használathoz a következőket kell tenni. A SAF keretrendszer leírásának megfelelően  el kell indítani egy dVRK PSM kar szimulációt \cite{irobotics2020May}. Majd egy SAF ''dummy`` objektumot kell elhelyezni a szimulációban. A szimulált kar állapotát ''home`` pozíció kell hozni. ''Dummy vision`` elindítás is szükséges. Következő szükséges lépés továbbra is a leírásának megfelelően irob\_robot szolgáltatás majd surgeme\_server szolgáltatás elindítása. A leírástól eltérve kell folyatni. Ez után a web\_actions modul futtatása szükséges. Következő lépésként pedig a '' rosbridge\_websocket`` futtatása szükséges. Ezek után meg vagyunk ROS oldalról. A következőkben az NodeJS szerver modul leírásának megfelelő utasítások futtatása szükséges \cite{aaronrancsik2020May}. Amennyiben ezzel is megvagyunk az alkalmazás localhost hálózton elindította szolgáltatásait. Melyet modern böngészők segítségivel el lehet érni.
\chapter*{Irodalomjegyzék}
\addcontentsline{toc}{chapter}{Irodalomjegyzék}  
\printbibliography[heading=none]
\newpage
\listoffigures
\addcontentsline{toc}{chapter}{Ábrák jegyzéke}


\end{document}